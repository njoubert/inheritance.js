<!doctype html>

<html>
<head>
<title>Javascript's Object System</title>
<link rel="stylesheet" type="text/css" href="presentation.css" />
<script src="jquery-1.6.1.min.js" type="text/javascript"></script>
<script src="fathom.js"></script>

<script src="CodeMirror-2.23/lib/codemirror.js"></script>
<link rel="stylesheet" href="CodeMirror-2.23/lib/codemirror.css">
<script src="json2.js"></script>
<script src="CodeMirror-2.23/mode/javascript/javascript.js"></script>
<script src="Class.js"></script>

<script>

var currentStr = "";
function log(str) {
  currentStr += (str + "<br/>");
}

function run(codeEditor, outputDiv, config) {
  currentStr = "";
  div = document.getElementById(outputDiv);
  var code = "";
  if (config.prelude) code = config.prelude;
  code += codeEditor.getValue();
  try {
    eval(code);
  } catch (err) {
    log(err);
  }
  div.innerHTML = currentStr;
}

function clear(outputDiv) {
    div = document.getElementById(outputDiv);
    div.innerHTML = "<br/>";
}

$(document).ready(function(){
  var fathom = new Fathom('#presentation', {
    onActivateSlide: function() {
     var $slide = $(this);
     $slide.find('pre:first').focus();
    },
    displayMode: "single"
	});
});

currEx = 0;
function createEditor(config) {
  currEx += 1;
  var cE = currEx;
  var div = document.getElementById(config.div);
  div.className = "code_example"
  div.innerHTML = '<div id="ex'+cE+'_code" class="js_code"></div> \
      <input type="button" id="ex'+cE+'_run" value="run!"> \
      <input type="button" id="ex'+cE+'_clear" value="reset"> \
      <div id="ex'+cE+'_result" class="js_result"><br/></div>'
      
    if (config.height) {
      document.getElementById("ex"+cE+"_code").style.height = config.height;
    }
    var ex1_editor = CodeMirror(document.getElementById('ex'+cE+'_code'), {
      value: config.value,
      mode:  "javascript",
      lineNumbers: true
    });
    $('#ex'+cE+'_code').bind("keypress", function(e) {
      if (e.keyCode == 18 && e.ctrlKey) {
        run(ex1_editor, 'ex'+cE+'_result', config);
      }
    });
    $('#ex'+cE+'_run').click(function() {
      run(ex1_editor, 'ex'+cE+'_result', config);
    })
    $('#ex'+cE+'_clear').click(function() {
      clear('ex'+cE+'_result');
    })
 
}
</script>
</head>
<body>

<div id="presentation">
	<div class="slide bb">
  		<h1><img src="images/y-u-no.jpg"/></h1>
  		<h2>Objects, Functions and Inheritance...</h2>
	  <div class="centered">

	  </div>
		
		<div class="footer">
			Niels Joubert - <a href="http://github.com/njoubert">@njoubert</a>
		</div>
	</div>
	
	<div class="slide bb">
		<h1>What am I up to?</h1>
		<ul>
			<li>Electronic Textbooks</li>
			<li>Device Independent Document Layout</li>
		</ul>
	</div>

	<div class="slide bb">
		<h1>The web is a great target platform</h1>
		<ul>
	<li>Same environment runs everywhere</li>
	<li>Days of standard issues are long gone</li>
	<li>Get around idiotic restrictions of most iShittyDevices</li>
	<li>Great designers are working in this area already</li>
		</ul>
	</div>

	<div class="slide bb">
		<h1>They understand layout (mostly)</h1>
      <img src="images/resizing.jpg"></img>
	</div>


	<div class="slide bb">
    <ul>
    <li class="big">"JavaScript is an amalgam of good parts and bad parts. Its best parts came from Self (prototypes) and Scheme (lexically scoped nested functions). But the interaction of those two very good parts produced some very bad parts." <br/><br/>-Douglas Crockford</li>
	  </ul>
	</div>

	<div class="slide bb">
		<h1>This talk</h1>
		<ul>
	<li>I fight with JavaScript on a daily basis,<br/> so I wrote a rant, so I'm giving a talk</li>
  <img src="images/email.png"/>
	
		</ul>
	</div>

	<div class="slide bb">
		<h1>Who's responsible</h1>
		<ul>
			<li>Brendan Eich, for Netscape 2, created it "within 10 days"</li>
			<li>"Else something worse than JS would have happened"</li>
			<li><br/></li>
			<li>The big idea: Validate forms on the client.</li>
			<li>Today: The most widely used language in the world*</li>
			<li></li>
		</ul>
		* Totally unsubstantiated claim.
	</div>
	
		<div class="slide bb">
		  <div class="centered">
		<h1>Let's play</h1>
		<br/>
		<h2>Objects, Functions, Inheritance</h2>
    </div>
	</div>

	<div class="slide">
		<h1>Object Creation</h1>	
		<ul>
      <li>Classes have two purposes: make things easy for compiler writers and keep poor programmers busy.*</li>
		  <div id="ex1"></div>
		</ul>
		* I am going to retract this statement in about 10 slides...
    <script>
    createEditor({
      value: "//Create an object\nvar obj = {}\n\n//Check type of object\nlog(typeof obj);",
      div: "ex1"
    })
	  </script>
	</div>


	<div class="slide">
		<h1>Objects are Dictionaries</h1>	
		<ul>
		  <li>Notice, identifies can be strings, or symbols. Bad?</li>
		  <div id="ex2"></div>
		</ul>
    <script>
    createEditor({
      value: "\
var a = {\n\
	name: \"Niels\"            //Object Literals\n\
};\n\
a.age = 25;                  //Object insertion\n\
a[\"lastname\"] = \"Joubert\"\n\
\n\
log(a.name);\n\
log(a.age);\n\
//log(a.lastname);",
      div: "ex2"
    })
	  </script>
	</div>
		


	<div class="slide">
		<h1>Functions</h1>	
		<ul>
      <li>First Class, Lexically Scoped, Nested Functions. <br/>Every language should have this</li>
		  <div id="ex3"></div>
		</ul>
    <script>
    createEditor({
      value: 
"var map = function(arr, fn) {\n\
  var result = [];\n\
  for (var i = 0; i < arr.length; i++) {\n\
    result.push(fn(arr[i]));\n\
  }\n\
  return result;\n\
}\n\
\n\
log(\"Map is a \" + typeof map);\n\
log(\"Map is a Function? \" + (map instanceof Function));\n\
log(\"Map is an object? \" + (map instanceof Object));\n\
\n\
//var count = 0;\n\
var newarr = map(\n\
  [1,2,3],\n\
  function(v) { return v + 1; });\n\
log(\"Mapped array: \" + newarr);\n\
//log(\"Elements counted: \" + count);",
      div: "ex3",
      height: "300px"
    })
	  </script>
	</div>
	


	<div class="slide">
		<h1>Functions and Objects</h1>	
		<ul>
      <li>Objects are dictionaries, functions are first class...<br/>Objects make great modules!</li>
		</ul>
		  <div id="ex4"></div>

    <script>
    createEditor({
      value: "var _ = {};\n\
_.map = function(a,f){var r=[];for(var i in a){r.push(f(a[i]));}return r;};\n\
\n\
log(\"_.Map is a Function? \" + (_.map instanceof Function));\n\
log(\"_.Map is an object? \" + (_.map instanceof Object));\n\
\n\
var count = 0;\n\
var newarr = _.map(\n\
  [1,2,3],\n\
  function(v) { count +=1; return v + 1; });\n\
log(\"Elements counted: \" + count);\n\
log(\"Mapped array: \" + newarr);",
      div: "ex4",
      height: "220px"
    })
	  </script>
	</div>


	<div class="slide">
		<h1>Implement Mixins</h1>	
		<ul>
      <li>Very cool, because we get to invent our own language features</li>
		</ul>
		  <div id="ex5"></div>
      Some language features are better than others.
    <script>
    createEditor({
      value: "var _ = {};\n\
_.mixin = function(target, src) {\n\
            for (var name in src) {\n\
              if (src.hasOwnProperty(name)) { //Don't search the prototype chain\n\
                target[name] = src[name];\n\
              }\n\
            }\n\
          };\n\
\n\
var utils = {};\n\
utils.map = function (a,f){var r=[];for(var i in a){r.push(f(a[i]));}return r;};\n\
//_.mixin(utils, _);\n\
\n\
log(\"utils.map exists? \" + (typeof utils.map));\n\
log(\"utils.mixin exists? \" + (typeof utils.mixin));\n",
      div: "ex5",
      height: "300px"
    })
	  </script>
	</div>

	

		<div class="slide bb">
		  <div class="centered">
		<h1>OK OK but let's use them as objects already</h1>
		<br/>
		<h2>Hint: It's gonna get rough</h2>
    </div>
	</div>
	
	<div class="slide">
		<h1>It Just Works!</h1>	
		<ul>
		  <div id="ex6"></div>
		</ul>
    <script>
    createEditor({
      value: "//Factory function:\n\
function getCounter() {\n\
	var counter = {\n\
		val: 0,\n\
		inc: function() {\n\
			return ++this.val;\n\
		}\n\
	}\n\
	return counter;\n\
}\n\
\n\
var c1 = getCounter();\n\
var c2 = getCounter();\n\
\n\
log(\"C1: \" + c1.val + \", C2: \" + c2.val);\n\
c1.inc();\n\
log(\"C1: \" + c1.val + \", C2: \" + c2.val);\n\
c2.inc();\n\
log(\"C1: \" + c1.val + \", C2: \" + c2.val);",
      div: "ex6",
      height: "400px"
    })
	  </script>
	</div>
		
<div class="slide">
  <h1>Function invocation and the magic "this" pointer</h1>
  <ul class="small">
  	<li>
  	  <ol>
  	    <li> <code>&ltident&gt()</code> lookup is scope chain, create new scope, execute code in it.</li>
  	    <li> <code>&ltobj&gt.&ltident&gt()</code> - lookup <code>&ltobj&gt</code> in scope chain, lookup <code>&ltident&gt</code> in object dict</li>
  	    BTW, there are two more that we will get to... (it's gonna get real ugly real soon...)
  	  </ol>
  	</li>
  	<br/>
  	<li>1] binds <code>this</code> to the global object</li>
  	<li>2] binds <code>this</code> to the <code>&ltobj&gt</code></li>
  	<li>This is a real tension here. Given the set of design decisions we made, we can't avoid deciding what to bind <code>this</code> to.</li>
  </ul>
  * Totally unsubstantiated claim.
</div>


<div class="slide">
  <h1>Mistake: "this" to global</h1>
  <ul class="small">
  	<li> <code>&ltident&gt()</code> binding <code>this</code> BREAKS NESTED FUNCTIONS!</li>
		  <div id="ex7"></div>
		</ul>
    <script>
    createEditor({
      value: "function getCounter() {\n\
	var counter = {\n\
		val: 0,\n\
		inc: function() {\n\
          function checkOverflow() {\n\
            if (this.val > 2) { this.val = 0; }\n\
          }\n\
          checkOverflow();\n\
		  return ++this.val;\n\
		}\n\
	}\n\
	return counter;\n\
}\n\
var c1 = getCounter();\n\
log(c1.inc());\n\
log(c1.inc());\n\
log(c1.inc());\n\
log(c1.inc());\n\
log(c1.inc());",
      div: "ex7",
      height: "320px"
    })
	  </script>

</div>

<div class="slide">
  <h1>Fix it with a feature</h1>
  <ul class="small">
  	<li>
  	  <ol>
  	    <li> <code>&ltident&gt()</code> - <code>this</code> is global</li>
  	    <li> <code>&ltobj&gt.&ltident&gt()</code> - <code>this</code> is <code>&ltobj&gt</code></li>
  	    <li> <code>&ltobj&gt.&ltident&gt.apply(this, args)</code> - specify <code>this</code> binding:</li>
      </ol></li>
		  <div id="ex8"></div>
		</ul>
    <script>
    createEditor({
      value: "function getCounter() {\n\
	var counter = {\n\
		val: 0,\n\
		inc: function() {\n\
          function checkOverflow() {\n\
            if (this.val > 2) { this.val = 0; }\n\
          }\n\
          checkOverflow.apply(this);\n\
		  return ++this.val;\n\
		}\n\
	}\n\
	return counter;\n\
}\n\
var c1 = getCounter();\n\
log(c1.inc());\n\
log(c1.inc());\n\
log(c1.inc());\n\
log(c1.inc());\n\
log(c1.inc()); ",
      div: "ex8",
      height: "250px"
    })
	  </script>

</div>
	

<div class="slide">
  <h1>apply and call</h1>
  <ul class="">
  	<li>Both allows you specify <code>this</code> binding</li>
  	<li>I want to call it bad, but...</li>
  	<li>Really useful all over the place!</li>
  	<li>Example:  <a href="https://github.com/njoubert/csp.js/blob/master/test/benchmark.js">testing/benchmarking with a setup and test function</a></li>
  </ul>
</div>


		<div class="slide bb">
		  <div class="centered">
		<h1>Inheritance</h1>
		<br/>
		<h2>Oh boy, oh boy, oh boy!</h2>
    </div>
	</div>


<div class="slide">
  <h1>An issue from before:</h1>
  <ul class="small">
  	<li>Code duplication:<br/>Because we don't have classes, functions just live on the object itself</li>
		  <div id="ex9"></div>
		</ul>
    <script>
    createEditor({
      value: "function getCounter() {\n\
	var counter = {\n\
		val: 0,\n\
		inc: function() {\n\
			return ++this.val;\n\
		}\n\
	}\n\
	return counter;\n\
}\n\
\n\
var c1 = getCounter();\n\
var c2 = getCounter();\n\
log(\"Same object? \" + (c1 === c2));\n\
log(\"Same function? \" + (c1.inc === c2.inc));\n",
      div: "ex9",
      height: "250px"
    })
	  </script>

</div>

<div class="slide">
  <h1>Hide it in the scope?</h1>
		  <div id="ex10"></div>
    <script>
    createEditor({
      value: "function makeCounterFactory() {\n\
	var inc = function() {\n\
		return ++this.val;\n\
	}\n\
    \n\
	var getCounter = function() {\n\
		var counter = {\n\
			val: 0,\n\
			inc: inc\n\
		}\n\
		return counter;\n\
	}\n\
	return getCounter;\n\
}\n\
\n\
var getCounter = makeCounterFactory();\n\
\n\
var c1 = getCounter();\n\
var c2 = getCounter();\n\
log(c1 === c2);\n\
log(c1.inc === c2.inc);",
      div: "ex10",
      height: "350px"
    })
	  </script>

</div>


<div class="slide">
  <h1>"Fake" private variables!</h1>
		  <div id="ex11"></div>
    <script>
    createEditor({
      value: "function makeCounterFactory() {\n\
	var counters = 0;\n\
	\n\
	var inc = function() { return ++this.val; }\n\
	var howmany = function() { return counters; }\n\
\n\
	var getCounter = function() {\n\
		counters += 1;\n\
		var counter = {\n\
			val: 0,\n\
			inc: inc,\n\
			howmany: howmany\n\
		}\n\
		return counter;\n\
	}\n\
	return getCounter;\n\
}\n\
\n\
var getCounter = makeCounterFactory();\n\
\n\
var c1 = getCounter();\n\
log(c1.howmany());\n\
var c2 = getCounter();\n\
log(c1.howmany());",
      div: "ex11",
      height: "400px"
    })
	  </script>

</div>

<div class="slide">
  <h1>
  <img src="images/scumbag_niels.jpg">
  </h1>
</div>

=== OK, but what about inheritance...

Since JavaScript is a Duck Typing language
<image of duck>
we don't have to care about type relationships, but we still care about:

- Shared functionality (efficiency on the programmer's side)
- Code reuse (efficiency on the compiler's side)
- Efficient Identification (think of the Visitor Pattern... DOM Traversal)

The idea is: Specialized objects derived from General objects, you only specify 

=== Prototypal inheritance:
Let's see what are Objects and Functions comprised of:

	var obj = {}
	log(obj);
	log(obj.__proto__);

	log("-");

	var func = function() {};
	log(func);
	log(func.__proto__);
	
So, as we expect, there is a pointer, __proto__, that points to the parent object.
So, let's try it:

	var animal = {
		makeNoise: function() {
			return this.noise;
		}
	}

	var duck = { noise: "quack" }
	var dog =  { noise: "woof"  }
	duck.__proto__ = animal;
	dog.__proto__ = animal;
	
	log(duck.makeNoise());
	log(dog.makeNoise());
	
IT WORKS!!!!

Now try:

	var animal = {
		makeNoise: function() {
			return this.noise;
		}
	}

	var duck = { noise: "quack" }
	var dog =  { noise: "woof"  }
	duck.__proto__ = animal;
	dog.__proto__ = animal;

	log(duck instanceof animal);
	log(dog instanceof animal);

YAY EVERYTHING BRREAKS! That's right... instanceof does not follow the prototype inheritance hierarchy... WTF?
Let's check check the docs:



<obj_proto>
	
WTF? OK, so we can't even use this, (and in fact it doesn't work in IE or Opera)
It's some internal interpreter thing...
We look further:
	
<obj_constructors>
	
DANGER AHEAD, here's the 4th function invocation I warned you guys about earlier!

	
=== Constructor Functions
This is, by far, BY FAR, the biggest mistake in Javascript.
This is a MAJOR MAJOR FUCKUP.
In fact, rumor has it, that this was not in the original internal javascript version,
but was later added to simulate Java constructors.

The intent is not bad:

	function Duck() {
	  this.makeNoise = function() { return this.noise; }
	  this.noise = "quack"
	}
	
	log(Duck.prototype);

	var duck1 = new Duck();

	log(duck1.noise);
	log(duck1.makeNoise());
	log("-");
	log("The constructor of duck1 is Duck(): " duck1.constructor === Duck);

Function invocation:
4) new <ident>():
	1) creates a new object (just a plain old object)
	2) sets this object's __proto__ to <ident>'s .prototype
	3) calls <ident> with `this` bound to the just-created object 
	4) return this new object.
	
OK, what the.....

=== Let me reveal how it looks:

Each object has:
	__proto__: this is used for identifier lookup in <obj>.<ident>
	.constructor: a pointer to the function that created this object using the `new` keyword

Each function, since we don't know whether it is a function or called with `new`, has:
	[[Scope]] which points to the execution context
	[[Code]] which points to a string representation of the function's code
	.prototype which points to a (settable, but initially empty) object

Each function carries a prototype object with it, and when new() gets called, the created object's __proto__ points to this. Thus...

=== Constructor functions can set an object's __proto__

So, this seems like a, uh, kinda a good intent. Imagine the compiler write:
right now it looks like the __proto__ can only be set by the constructor
during object creation

	function Animal() {}
	log(JSON.stringify(Animal.prototype));
	Animal.prototype.makeNoise = function() { return this.noise; }

	dog = new Animal();
	duck = new Animal();

	dog.noise = "woof";
	duck.noise = "quack";

	log(dog.makeNoise());
	log(duck.makeNoise());
	
<Show diagram>

=== So, let's look at the original inheritance example:

	function Duck() { this.noise = "quack"; }
	Duck.prototype = new Animal();
	
	function Dog() { this.noise = "woof"; }
	Dog.prototype = new Animal();

	var duck = new Duck();
	var dog = new Dog();
	log(duck.noise);
	log(dog.noise);

	log(duck.makeNoise());
	log(dog.makeNoise());

<Show diagram>

BTW, notice how much this sucks:
- we have constructor functions, but you only run them ONCE when you define the class!
Thus you end up with idiotic duplicated code like this:

	function Animal(name) {
		this.name = name;
	}
	
	function Dog(name, age) {
		this.name = name;
		this.age = age;
	}
	Dog.prototype = new Animal("bogus name");
	
WHAT THE FUCK? SO WHY DO WE EVEN HAVE CONSTRUCTOR FUNCTIONS?!
you guys REALLY SHOT YOURSELF IN THE FOOT WITH THIS ONE!

=== OK, so let's get into this a little bit:

This is Classical Inheritance: Show skyscraper with blueprints

This is Prototypal Inheritance: Show hacker copying 

This is Pseudoclassical: Show fat hacker kid

This is what they call "pseudoclassical" inheritance. The muddled-up bastard offspring that JavaScript came up with:
- when we want to create inheritance hierarchies in JavaScript:
- we create a constructor function for each "Class".
- we use the prototype object to store "class-wide" things
- if we want to create an inheritance hierarchy, we use the prototype to point to a new object of the parent type. this object will, again, have a prototype object with the parent's class-wide functions on it.


=== Aside: what if you call a constructor function without using new?

BAD PART, AGAIN!

	function Animal(name) {
		this.name = name;
	}

	var dog = Animal("Einstein");

	log(dog.name);

	//log(name);
	//log(window.name);




=== What could they have done?

1) Have a separate Constructor, different from a normal function?
2) Stick with "self"-style and just have an object's parent pointer exposed and settable
3) 

= Clearly this needs to be tamed.

= Crockford: Hey, let's introduce a NEW way to generate Objects!
OK, if we love self (and we do!) and we just want purely prototypal inheritance:

	function object(o) {
	  function F() {}
	  F.prototype = o;
	  return new F();
	}

	var animal = object({});
	animal.makeNoise = function() { return this.noise; };

	var dog = object(animal);
	dog.noise = "woof";

	log(dog.makeNoise());

Downsides:

1) Instanceof still doesn't work:

	log(dog instanceof animal) //still fails
	log(animal.isPrototypeOf(dog)) //they added a feature to make this work... messy

	Now, this is really messy to me. Two different ways to work with inheritance, yeack!
	and isPrototypeOf() is pretty new - not supported everywhere yet.

2) We lost the ability to have constructors
	

3) No differentiation between 'class' and 'object' (but that might be okay).
And this is a bit weird to most programmers, though:

	function object(o) {
	  function F() {}
	  F.prototype = o;
	  return new F();
	}

	var animal = object({});
	animal.makeNoise = function() { return this.noise; };

	var dog = object(animal);
	dog.noise = "woof";

	var dog1 = object(dog);
	var dog2 = object(dog);
	log(dog.makeNoise());


= Then there are a TON of different ways you get to "fake" classical inheritance

They all have tradeoffs between speed, memory, visibility and ugliness.

I have 5 different ways documented as part of the rant that inspired this talk: 
https://github.com/njoubert/inheritance.js

= My way:

- Differentiate between Classes and Objects: makes it easy to decide where code should live (Classes, not duplicated)
- I want a "constructor"
- I want "constructors" to be able to call parent constructors, else it's pointless to have them
- I want instanceof to work so that I can use the visitor pattern effectively.
- I want to minimize code duplication (aka lightweight objects): no storing of functions on all the objects
- Use the fast path for "new", to create lightweight objects

Here is an example of using my library:

	var Animal = Class.extend({
		makeNoise: function() { return this.noise; }
	});

	var Dog = Animal.extend({
		noise: "woof"
	});

	var Duck = Animal.extend({
		noise: "duck"
	});

	var dog = new Dog();
	var duck = new Duck();
	log(dog.makeNoise());
	log(duck.makeNoise());
	
	log("duck instanceof Duck: " + (duck instanceof Duck));
	log("duck instanceof Animal: " + (duck instanceof Animal));

=== OK, I'm going to admit... still one ugly part left:
Dog and Duck both have the same __proto__, which is Animal's prototype.
Since "this" is bound to the right-most object, we still have to use the funky "call"/"apply" semantics:

	var Animal = Class.extend({
		init: function (name) { this.name = name},
		makeNoise: function() { return this.noise; }
	});

	var Dog = Animal.extend({
		init: function(name) { this.parent.init.call(this,name); },
		noise: "woof"
	});

	var Duck = Animal.extend({
		init: function(name) { this.parent.init.call(this,name); },
		noise: "duck"
	});

	var dog = new Dog("Einstein");
	var duck = new Duck("Newton");
	log(dog.makeNoise());
	log(duck.makeNoise());
	log(dog.name);
	log(duck.name);


= How does this work?


	var Class = function(){};
	Class.extend = function(prop) {
	  initializing = true;
	  //first we create a new empty object of the current type
	  var prototype = new this();
	  initializing = false;

	  for (var name in prop) {
	    if (prop.hasOwnProperty(name)) {
	      prototype[name] = prop[name];
	    }
	  }

	  //Now we set up our Constructor function which will create objects:
	  function SubClass() {
	    if (!initializing && prototype.init) {
	      prototype.init.apply(this,arguments)
	    }
	  }
	  //Associate the prototype and constructor with this Constructor
	  SubClass.prototype = prototype;
	  SubClass.prototype.constructor = SubClass;
  
	  //Grab the parent pointer so we can call up the inheritance hierarchy:
	  SubClass.prototype.parent = this.prototype;
  
	  //Finally, save the "extend" method on the newly created Constructor function:
	  SubClass.extend = arguments.callee
	  return SubClass;

	}

= Cool huh? Well, one last issue
Debuggers identify objects by the name of their constructor function: In this case, everything is called "SubClass"

So we can improve on this by using one of the bad parts to our advantage: eval():
Now we build a constructor function of the correct name.

	var Class = function(){};
	Class.extend = function(prop, className) {
	  initializing = true;
	  //first we create a new empty object of the current type
	  var prototype = new this();
	  initializing = false;

	  for (var name in prop) {
	    if (prop.hasOwnProperty(name)) {
	      prototype[name] = prop[name];
	    }
	  }

	  eval("function " + className + "() { \
	    if (!(this instanceof arguments.callee)) { \
	      throw { name: \"ClassError\", message: \"Called constructor without using 'new'.\"} \
	    } \
	    if (!initializing && prototype.init) { \
	      if (arguments.length !== prototype.init.length) { \
	        throw { name: \"ClassError\",  message: \"Called constructor with incorrect number of arguments.\" } \
	      } \
	      prototype.init.apply(this,arguments); \
	    } \
	  };"
	  + className + ".prototype = prototype;"
	  + className + ".prototype.constructor = SubClass;"
	  + className + ".prototype.parent = this.prototype;"
	  + className + ".extend = arguments.callee;");
	  return eval(className);

	}

= And we'll call it a day with that. Recap:

Great things: lexically scoped first class functions, prototypal inheritance

Weird things:

4 different invocation styles in JavaScript.
The `this` pointer is painful!
Constructor functions are a horrible design
eval() is both good and evil

Overall:
	I think it's hugely cool that everyone can invent their own JS as they go along to suit their needs.

= ECMAScript 6

Proposal: New anonymous functions
	(x) => x * x
Always binds "this" to enclosing scope. Even when called as method.
To have "this" receive a dynamic binding to an object:
	(this, x) => this.property = x * x




</div>

</body>
</html>

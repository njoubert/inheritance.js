{"name":"Inheritance.js","body":"# INHERITANCE.JS\r\n\r\n*A simple base class for your javascript needs.*\r\n\r\nThis class inheritance structure gives up private variables,\r\nsince you cannot return an object from your constructor and\r\nhave the hierarchy still work.\r\n\r\nThere is a tension between creating scopes to hold private variables,\r\n which necessitates that all the functions also be created in this scope\r\n to access these variables, and\r\nhaving constructor functions to instantiate objects but having functions\r\n on the prototype of these constructor functions to avoid duplication.\r\n\r\n## Dependencies\r\n\r\n- require.js (optional)\r\n\r\n## Issues with this approach\r\n\r\nUnfortunately every pseudoclass in my system has \"SubClass\" as a constructor, \r\nthus something like FireBug or Chrome Developer Tools look a little ugly\r\nwhen you're printing things out.\r\n\r\nThis is fixed by passing a string argument with the name you want, but that's not very DRY, so i'm not a huge fan.\r\n\r\n## Fundamental reasons why I want something like this.\r\n\r\nWhat makes this process difficult is: I want to distinguish between internal\r\nlibrary functionality and an external API. This is why thing like public-private\r\nare useful. The Revealing Module pattern is a nice way of achieving this for\r\nModules, but for Classes there seems to be no equivalent.\r\n\r\nThe difference is: for Classes you do not want to duplicate code on every instance,\r\nwhile for Modules this is not an issue, since you tend to only instantiate one copy\r\nof each module,\r\n\r\nI like my approach slightly more than prototype.js (Alex Arnell)'s implementation,\r\nsince I don't need a `super()` method everywhere.\r\n\r\n## Understanding Javascript Inheritance\r\n\r\nSee `inheritance.md` for an overview of javascript inheritance.","tagline":"A simple inheritance library for you pseudoclassical needs","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}